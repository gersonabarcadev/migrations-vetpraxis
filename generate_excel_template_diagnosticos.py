#!/usr/bin/env python3
"""
Generador de templates Excel para importaci√≥n de diagn√≥sticos
Nueva estructura espec√≠fica con IDs correlativos

Formato de salida:
A => import_clinic_record_id (correlativo desde 99869913)
B => PatientId 
C => DataDate (fecha de diagn√≥stico)
D => Note (diagnosticos.Name + [PARRAFO] + pacientediagnosticos.Note)
"""

import pandas as pd
import numpy as np
from datetime import datetime
import os
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment

def load_and_prepare_data():
    """Cargar y preparar datos de diagn√≥sticos"""
    print("üìñ Cargando datos de diagn√≥sticos...")
    
    new_file = "/Users/enrique/Proyectos/imports/source/cuvet-v2.xlsx"
    
    if not os.path.exists(new_file):
        raise FileNotFoundError(f"Archivo no encontrado: {new_file}")
    
    # Cargar ambas pesta√±as
    df_diagnosticos = pd.read_excel(new_file, sheet_name='diagnosticos', engine='openpyxl')
    df_pacientediagnosticos = pd.read_excel(new_file, sheet_name='pacientediagnosticos', engine='openpyxl')
    
    print(f"‚úÖ Cat√°logo de diagn√≥sticos: {len(df_diagnosticos):,} registros")
    print(f"‚úÖ Aplicaciones de diagn√≥sticos: {len(df_pacientediagnosticos):,} registros")
    
    # Filtrar solo registros activos (no eliminados)
    if 'IsDeleted' in df_pacientediagnosticos.columns:
        df_active = df_pacientediagnosticos[df_pacientediagnosticos['IsDeleted'] == 0].copy()
        eliminados = len(df_pacientediagnosticos) - len(df_active)
        print(f"üóëÔ∏è  Eliminados: {eliminados:,} registros ({eliminados/len(df_pacientediagnosticos)*100:.1f}%)")
    else:
        df_active = df_pacientediagnosticos.copy()
    
    print(f"üìä Registros activos para procesar: {len(df_active):,}")
    
    # Convertir fechas
    df_active['DataDate'] = pd.to_datetime(df_active['DataDate'])
    
    # Crear diccionario de nombres de diagn√≥sticos
    diagnostic_names = dict(zip(df_diagnosticos['DiagnosticId'], df_diagnosticos['Name']))
    
    print(f"üîó Cat√°logo de diagn√≥sticos disponible: {len(diagnostic_names)} tipos")
    
    return df_active, diagnostic_names

def process_diagnostic_records(df_active, diagnostic_names):
    """Procesar registros de diagn√≥sticos para importaci√≥n"""
    print("\nüîÑ Procesando registros de diagn√≥sticos...")
    
    records = []
    current_id = 99869913  # ID inicial correlativo (siguiente despu√©s de procedimientos)
    
    # Ordenar por fecha para mantener secuencia l√≥gica
    df_sorted = df_active.sort_values(['DataDate', 'PatientId']).reset_index(drop=True)
    
    for idx, row in df_sorted.iterrows():
        try:
            # Datos b√°sicos
            patient_id = int(row['PatientId'])
            data_date = row['DataDate']
            diagnostic_id = int(row['DiagnosticId'])
            note = row.get('Note', '') if pd.notna(row.get('Note', '')) else ''
            
            # Obtener nombre del diagn√≥stico
            diagnostic_name = diagnostic_names.get(diagnostic_id, f"Diagn√≥stico ID {diagnostic_id}")
            
            # Construir campo Note seg√∫n especificaci√≥n
            if note.strip():
                # Hay nota: Nombre + [PARRAFO] + Nota
                formatted_note = f"{diagnostic_name}[PARRAFO]{note.strip()}"
            else:
                # Sin nota: Solo nombre
                formatted_note = diagnostic_name
            
            # Crear registro
            record = {
                'import_clinic_record_id': current_id,
                'PatientId': patient_id,
                'DataDate': data_date,
                'Note': formatted_note
            }
            
            records.append(record)
            current_id += 1
            
            # Progreso cada 5000 registros
            if (idx + 1) % 5000 == 0:
                print(f"   Procesados: {idx + 1:,}/{len(df_sorted):,} registros...")
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error procesando registro {idx}: {e}")
            continue
    
    df_result = pd.DataFrame(records)
    print(f"‚úÖ Procesados exitosamente: {len(df_result):,} registros")
    print(f"üÜî IDs asignados: {99869913} - {current_id - 1}")
    
    return df_result

def create_excel_template(df_data, output_dir):
    """Crear archivo Excel con formato espec√≠fico"""
    print(f"\nüìù Generando template Excel...")
    
    # Crear directorio si no existe
    os.makedirs(output_dir, exist_ok=True)
    
    # Configuraci√≥n de archivos
    records_per_file = 10000  # 10K registros por archivo
    total_records = len(df_data)
    num_files = (total_records + records_per_file - 1) // records_per_file
    
    print(f"üìä Total registros: {total_records:,}")
    print(f"üìÅ Archivos a generar: {num_files}")
    print(f"üìÑ Registros por archivo: {records_per_file:,}")
    
    generated_files = []
    
    for file_num in range(num_files):
        start_idx = file_num * records_per_file
        end_idx = min(start_idx + records_per_file, total_records)
        df_chunk = df_data.iloc[start_idx:end_idx]
        
        # Nombre del archivo
        filename = f"diagnosticos_import_{file_num + 1:02d}.xlsx"
        filepath = os.path.join(output_dir, filename)
        
        # Crear workbook
        wb = Workbook()
        ws = wb.active
        ws.title = "Diagnosticos Import"
        
        # Headers
        headers = [
            'A: Import Clinic Record ID',
            'B: Import Pet ID',
            'C: Import Date',
            'D: Note'
        ]
        
        # Estilo para headers
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
        center_alignment = Alignment(horizontal="center", vertical="center")
        
        # Escribir headers
        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col, value=header)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = center_alignment
        
        # Escribir datos
        for row_idx, (_, record) in enumerate(df_chunk.iterrows(), 2):
            ws.cell(row=row_idx, column=1, value=record['import_clinic_record_id'])
            ws.cell(row=row_idx, column=2, value=record['PatientId'])
            ws.cell(row=row_idx, column=3, value=record['DataDate'].strftime('%Y-%m-%d %H:%M:%S'))
            ws.cell(row=row_idx, column=4, value=record['Note'])
        
        # Ajustar ancho de columnas
        column_widths = [25, 15, 20, 80]
        for col, width in enumerate(column_widths, 1):
            ws.column_dimensions[ws.cell(row=1, column=col).column_letter].width = width
        
        # Guardar archivo
        wb.save(filepath)
        generated_files.append(filepath)
        
        print(f"   ‚úÖ {filename}: {len(df_chunk):,} registros (IDs: {df_chunk.iloc[0]['import_clinic_record_id']} - {df_chunk.iloc[-1]['import_clinic_record_id']})")
    
    return generated_files

def generate_summary_report(df_data, output_dir):
    """Generar reporte resumen"""
    print(f"\nüìä Generando reporte resumen...")
    
    summary_file = os.path.join(output_dir, "resumen_diagnosticos_import.txt")
    
    with open(summary_file, 'w', encoding='utf-8') as f:
        f.write("RESUMEN DE IMPORTACI√ìN - DIAGN√ìSTICOS\n")
        f.write("=" * 50 + "\n\n")
        
        f.write(f"Fecha de generaci√≥n: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"Total de registros procesados: {len(df_data):,}\n")
        f.write(f"Rango de IDs asignados: {df_data['import_clinic_record_id'].min()} - {df_data['import_clinic_record_id'].max()}\n\n")
        
        # Estad√≠sticas por fecha
        f.write("DISTRIBUCI√ìN POR A√ëO:\n")
        year_counts = df_data['DataDate'].dt.year.value_counts().sort_index()
        for year, count in year_counts.items():
            f.write(f"  {year}: {count:,} diagn√≥sticos\n")
        
        f.write(f"\nRANGO DE FECHAS:\n")
        f.write(f"  Desde: {df_data['DataDate'].min()}\n")
        f.write(f"  Hasta: {df_data['DataDate'].max()}\n")
        
        # An√°lisis de notas con/sin contenido adicional
        notes_with_paragraph = df_data['Note'].str.contains(r'\[PARRAFO\]', na=False).sum()
        notes_only_name = len(df_data) - notes_with_paragraph
        
        f.write(f"\nESTAD√çSTICAS DE NOTAS:\n")
        f.write(f"  Solo nombre del diagn√≥stico: {notes_only_name:,} ({notes_only_name/len(df_data)*100:.1f}%)\n")
        f.write(f"  Con notas adicionales: {notes_with_paragraph:,} ({notes_with_paragraph/len(df_data)*100:.1f}%)\n")
        
        # Top diagn√≥sticos
        # Extraer nombres de diagn√≥sticos de las notas
        diagnostic_names = []
        for note in df_data['Note']:
            if '[PARRAFO]' in note:
                diagnostic_name = note.split('[PARRAFO]')[0]
            else:
                diagnostic_name = note
            diagnostic_names.append(diagnostic_name)
        
        f.write(f"\nTOP 10 DIAGN√ìSTICOS M√ÅS FRECUENTES:\n")
        diagnostic_counts = pd.Series(diagnostic_names).value_counts().head(10)
        for diagnostic, count in diagnostic_counts.items():
            f.write(f"  {diagnostic}: {count:,} diagn√≥sticos\n")
        
        # Estad√≠sticas de pacientes
        f.write(f"\nESTAD√çSTICAS DE PACIENTES:\n")
        f.write(f"  Pacientes √∫nicos: {df_data['PatientId'].nunique():,}\n")
        f.write(f"  Promedio diagn√≥sticos por paciente: {len(df_data)/df_data['PatientId'].nunique():.2f}\n")
        
        f.write(f"\nFORMATO DE ARCHIVOS:\n")
        f.write(f"  Columna A: Import Clinic Record ID (correlativo desde 99869913)\n")
        f.write(f"  Columna B: Import Pet ID (PatientId original)\n")
        f.write(f"  Columna C: Import Date (fecha de diagn√≥stico)\n")
        f.write(f"  Columna D: Note (Nombre[PARRAFO]Nota o solo Nombre)\n")
        f.write(f"\nSEPARADOR:\n")
        f.write(f"  [PARRAFO] - Para separar nombre del diagn√≥stico de notas adicionales\n")
        f.write(f"  Se puede reemplazar con saltos de l√≠nea en base de datos\n")
    
    print(f"‚úÖ Reporte guardado: {summary_file}")

def generate_validation_samples(df_data, output_dir):
    """Generar muestras para validaci√≥n"""
    print(f"\nüîç Generando muestras de validaci√≥n...")
    
    samples_file = os.path.join(output_dir, "muestras_validacion.txt")
    
    with open(samples_file, 'w', encoding='utf-8') as f:
        f.write("MUESTRAS DE VALIDACI√ìN - DIAGN√ìSTICOS\n")
        f.write("=" * 50 + "\n\n")
        
        # Muestras con notas adicionales
        with_notes = df_data[df_data['Note'].str.contains(r'\[PARRAFO\]', na=False)].head(5)
        f.write("EJEMPLOS CON NOTAS ADICIONALES:\n")
        f.write("-" * 30 + "\n")
        for i, (_, row) in enumerate(with_notes.iterrows(), 1):
            f.write(f"Ejemplo {i}:\n")
            f.write(f"  ID: {row['import_clinic_record_id']}\n")
            f.write(f"  Paciente: {row['PatientId']}\n")
            f.write(f"  Fecha: {row['DataDate']}\n")
            f.write(f"  Nota completa: {row['Note'][:200]}{'...' if len(row['Note']) > 200 else ''}\n\n")
        
        # Muestras solo con nombre
        without_notes = df_data[~df_data['Note'].str.contains(r'\[PARRAFO\]', na=False)].head(5)
        f.write("EJEMPLOS SOLO CON NOMBRE DE DIAGN√ìSTICO:\n")
        f.write("-" * 40 + "\n")
        for i, (_, row) in enumerate(without_notes.iterrows(), 1):
            f.write(f"Ejemplo {i}:\n")
            f.write(f"  ID: {row['import_clinic_record_id']}\n")
            f.write(f"  Paciente: {row['PatientId']}\n")
            f.write(f"  Fecha: {row['DataDate']}\n")
            f.write(f"  Nota: {row['Note']}\n\n")
    
    print(f"‚úÖ Muestras guardadas: {samples_file}")

def main():
    print("üè• GENERADOR DE TEMPLATES - DIAGN√ìSTICOS")
    print("=" * 50)
    
    output_dir = "/Users/enrique/Proyectos/imports/generated_files/diagnosticos"
    
    try:
        # 1. Cargar datos
        df_active, diagnostic_names = load_and_prepare_data()
        
        # 2. Procesar registros
        df_result = process_diagnostic_records(df_active, diagnostic_names)
        
        if len(df_result) == 0:
            print("‚ùå No hay registros para procesar")
            return
        
        # 3. Crear templates Excel
        generated_files = create_excel_template(df_result, output_dir)
        
        # 4. Generar reporte resumen
        generate_summary_report(df_result, output_dir)
        
        # 5. Generar muestras de validaci√≥n
        generate_validation_samples(df_result, output_dir)
        
        # 6. Resumen final
        print(f"\nüéâ ¬°GENERACI√ìN COMPLETADA!")
        print(f"üìÅ Directorio: {output_dir}")
        print(f"üìÑ Archivos generados: {len(generated_files)}")
        print(f"üìä Total registros: {len(df_result):,}")
        print(f"üè• Pacientes √∫nicos: {df_result['PatientId'].nunique():,}")
        print(f"üÜî Rango IDs: {df_result['import_clinic_record_id'].min()} - {df_result['import_clinic_record_id'].max()}")
        
        # Estad√≠sticas de formato
        with_notes = df_result['Note'].str.contains(r'\[PARRAFO\]', na=False).sum()
        without_notes = len(df_result) - with_notes
        print(f"üìù Solo nombre: {without_notes:,} ({without_notes/len(df_result)*100:.1f}%)")
        print(f"üìù Con notas adicionales: {with_notes:,} ({with_notes/len(df_result)*100:.1f}%)")
        
        # Mostrar archivos generados
        print(f"\nüìã Archivos creados:")
        for filepath in generated_files:
            filename = os.path.basename(filepath)
            print(f"   ‚Ä¢ {filename}")
        print(f"   ‚Ä¢ resumen_diagnosticos_import.txt")
        print(f"   ‚Ä¢ muestras_validacion.txt")
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
